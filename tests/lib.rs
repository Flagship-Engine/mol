use mol::math::{Vec2, Vec3};
use std::path::Path;

#[test]
fn load_basic() {
    let model = match mol::obj::OBJ::from_path(Path::new("tests/cube.obj")) {
        Ok(model) => model,
        Err(err) => panic!("OBJ error: {:?}", err),
    };
    // println!("{:?}", model);

    model.flat_iter().for_each(|(v, u, n)| {
        println!("{:?} {:?} {:?}", v, u, n);
    });
}

#[test]
fn load_cube_vn() {
    let model = match mol::obj::OBJ::from_path(Path::new("tests/cube_vn.obj")) {
        Ok(model) => model,
        Err(err) => panic!("OBJ error: {:?}", err),
    };

    macro_rules! vertices {
        ($( (p: $p:tt, uv: $uv:tt, n: $n:tt),)*) => {
            [$(( Vec3::new $p, Vec2::new $uv, Vec3::new $n, )),*]
        };
    }

    let expected = vertices! {
        (p: (  1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  1.0,  0.0 )),
        (p: ( -1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  1.0,  0.0 )),
        (p: ( -1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  1.0,  0.0 )),
        (p: (  1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  1.0,  0.0 )),
        (p: (  1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0,  1.0 )),
        (p: (  1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0,  1.0 )),
        (p: ( -1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0,  1.0 )),
        (p: ( -1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0,  1.0 )),
        (p: ( -1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: (-1.0,  0.0,  0.0 )),
        (p: ( -1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: (-1.0,  0.0,  0.0 )),
        (p: ( -1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: (-1.0,  0.0,  0.0 )),
        (p: ( -1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: (-1.0,  0.0,  0.0 )),
        (p: ( -1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0, -1.0,  0.0 )),
        (p: (  1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0, -1.0,  0.0 )),
        (p: (  1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0, -1.0,  0.0 )),
        (p: ( -1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0, -1.0,  0.0 )),
        (p: (  1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 1.0,  0.0,  0.0 )),
        (p: (  1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 1.0,  0.0,  0.0 )),
        (p: (  1.0,  1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 1.0,  0.0,  0.0 )),
        (p: (  1.0, -1.0,  1.0 ), uv: ( 0.0,  0.0 ), n: ( 1.0,  0.0,  0.0 )),
        (p: ( -1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0, -1.0 )),
        (p: ( -1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0, -1.0 )),
        (p: (  1.0,  1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0, -1.0 )),
        (p: (  1.0, -1.0, -1.0 ), uv: ( 0.0,  0.0 ), n: ( 0.0,  0.0, -1.0 )),
    };

    model
        .flat_iter()
        .zip(expected.iter())
        .enumerate()
        .for_each(|(i, (a, e))| assert_eq!(&a, e, "(output index {})", i));
}
